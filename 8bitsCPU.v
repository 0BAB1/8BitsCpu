/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */

module DemuxBus2
#(
    parameter Bits = 2,
    parameter Default = 0 
)
(
    output [(Bits-1):0] out_0,
    output [(Bits-1):0] out_1,
    output [(Bits-1):0] out_2,
    output [(Bits-1):0] out_3,
    input [1:0] sel,
    input [(Bits-1):0] in
);
    assign out_0 = (sel == 2'h0)? in : Default;
    assign out_1 = (sel == 2'h1)? in : Default;
    assign out_2 = (sel == 2'h2)? in : Default;
    assign out_3 = (sel == 2'h3)? in : Default;
endmodule


module Demux2
#(
    parameter Default = 0 
)
(
    output out_0,
    output out_1,
    output out_2,
    output out_3,
    input [1:0] sel,
    input in
);
    assign out_0 = (sel == 2'h0)? in : Default;
    assign out_1 = (sel == 2'h1)? in : Default;
    assign out_2 = (sel == 2'h2)? in : Default;
    assign out_3 = (sel == 2'h3)? in : Default;
endmodule


module DIG_Register_BUS #(
    parameter Bits = 1
)
(
    input C,
    input en,
    input [(Bits - 1):0]D,
    output [(Bits - 1):0]Q
);

    reg [(Bits - 1):0] state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule

module Mux_4x1_NBits #(
    parameter Bits = 2
)
(
    input [1:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            2'h0: out = in_0;
            2'h1: out = in_1;
            2'h2: out = in_2;
            2'h3: out = in_3;
            default:
                out = 'h0;
        endcase
    end
endmodule


module Registers (
  input Clock,
  input EnableWrite,
  input [3:0] Data,
  input [1:0] address,
  output [3:0] \output 
);
  wire [3:0] s0;
  wire s1;
  wire [3:0] s2;
  wire [3:0] s3;
  wire s4;
  wire [3:0] s5;
  wire [3:0] s6;
  wire s7;
  wire [3:0] s8;
  wire [3:0] s9;
  wire s10;
  wire [3:0] s11;
  DemuxBus2 #(
    .Bits(4),
    .Default(0)
  )
  DemuxBus2_i0 (
    .sel( address ),
    .in( Data ),
    .out_0( s0 ),
    .out_1( s3 ),
    .out_2( s6 ),
    .out_3( s9 )
  );
  Demux2 #(
    .Default(0)
  )
  Demux2_i1 (
    .sel( address ),
    .in( EnableWrite ),
    .out_0( s1 ),
    .out_1( s4 ),
    .out_2( s7 ),
    .out_3( s10 )
  );
  // R1
  DIG_Register_BUS #(
    .Bits(4)
  )
  DIG_Register_BUS_i2 (
    .D( s0 ),
    .C( Clock ),
    .en( s1 ),
    .Q( s2 )
  );
  // R2
  DIG_Register_BUS #(
    .Bits(4)
  )
  DIG_Register_BUS_i3 (
    .D( s3 ),
    .C( Clock ),
    .en( s4 ),
    .Q( s5 )
  );
  // R3
  DIG_Register_BUS #(
    .Bits(4)
  )
  DIG_Register_BUS_i4 (
    .D( s6 ),
    .C( Clock ),
    .en( s7 ),
    .Q( s8 )
  );
  // R4
  DIG_Register_BUS #(
    .Bits(4)
  )
  DIG_Register_BUS_i5 (
    .D( s9 ),
    .C( Clock ),
    .en( s10 ),
    .Q( s11 )
  );
  Mux_4x1_NBits #(
    .Bits(4)
  )
  Mux_4x1_NBits_i6 (
    .sel( address ),
    .in_0( s2 ),
    .in_1( s5 ),
    .in_2( s8 ),
    .in_3( s11 ),
    .out( \output  )
  );
endmodule
module DIG_Add
#(
    parameter Bits = 1
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits - 1):0] s,
    output c_o
);
   wire [Bits:0] temp;

   assign temp = a + b + c_i;
   assign s = temp [(Bits-1):0];
   assign c_o = temp[Bits];
endmodule



module DIG_Sub #(
    parameter Bits = 2
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits-1):0] s,
    output c_o
);
    wire [Bits:0] temp;

    assign temp = a - b - c_i;
    assign s = temp[(Bits-1):0];
    assign c_o = temp[Bits];
endmodule


module ALU (
  input [3:0] Data,
  input [3:0] RegData,
  input [1:0] OP,
  output [3:0] Result
);
  wire [3:0] s0;
  wire [3:0] s1;
  wire [3:0] s2;
  wire [3:0] s3;
  wire [3:0] s4;
  wire [3:0] s5;
  wire [3:0] s6;
  wire [3:0] s7;
  wire [3:0] s8;
  wire [3:0] s9;
  wire [7:0] s10;
  DemuxBus2 #(
    .Bits(4),
    .Default(0)
  )
  DemuxBus2_i0 (
    .sel( OP ),
    .in( Data ),
    .out_0( s0 ),
    .out_1( s3 ),
    .out_2( s6 ),
    .out_3( s7 )
  );
  DemuxBus2 #(
    .Bits(4),
    .Default(0)
  )
  DemuxBus2_i1 (
    .sel( OP ),
    .in( RegData ),
    .out_0( s1 ),
    .out_1( s4 )
  );
  DIG_Add #(
    .Bits(4)
  )
  DIG_Add_i2 (
    .a( s0 ),
    .b( s1 ),
    .c_i( 1'b0 ),
    .s( s2 )
  );
  DIG_Sub #(
    .Bits(4)
  )
  DIG_Sub_i3 (
    .a( s3 ),
    .b( s4 ),
    .c_i( 1'b0 ),
    .s( s5 )
  );
  assign s10[3:0] = s6;
  assign s10[7:4] = s7;
  assign s8 = s10[3:0];
  assign s9 = s10[7:4];
  Mux_4x1_NBits #(
    .Bits(4)
  )
  Mux_4x1_NBits_i4 (
    .sel( OP ),
    .in_0( s2 ),
    .in_1( s5 ),
    .in_2( s8 ),
    .in_3( s9 ),
    .out( Result )
  );
endmodule

module \8bitsCPU  (
  input OP1,
  input Addr1,
  input Clk,
  input D1,
  input D2,
  input D3,
  input D4,
  input Addr2,
  input OP2,
  input EW,
  output [3:0] DataDisplay
);
  wire [3:0] s0;
  wire [1:0] s1;
  wire [3:0] DataDisplay_temp;
  wire [3:0] s2;
  wire [1:0] s3;
  assign s3[0] = OP1;
  assign s3[1] = OP2;
  assign s1[0] = Addr1;
  assign s1[1] = Addr2;
  assign s2[0] = D1;
  assign s2[1] = D2;
  assign s2[2] = D3;
  assign s2[3] = D4;
  Registers Registers_i0 (
    .Clock( Clk ),
    .EnableWrite( EW ),
    .Data( s0 ),
    .address( s1 ),
    .\output ( DataDisplay_temp )
  );
  ALU ALU_i1 (
    .Data( s2 ),
    .RegData( DataDisplay_temp ),
    .OP( s3 ),
    .Result( s0 )
  );
  assign DataDisplay = DataDisplay_temp;
endmodule
